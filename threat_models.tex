\section{Usage Scenarios and Threat Models}
    *** This section is not yet complete

    This section describes some example applications for the architecture and 
    the threat model for each usage scenario.

    \subsection{DRM Video Playback}
    Mobile devices often support applications that playback videos with
    DRM restrictions. For example, a user may only be able to play a video if 
    he or she has a valid subscription to the service. In this case, the 
    attacker is the owner of the mobile device who would either like to access 
    content without paying for a subscription. The adversary is capable of any 
    software attack which includes the exploitation of timing channels.

    \subsubsection{DRM Protection Security Mechanisms}

    To play the DRM protected video, the secure world must first authenticate 
    the user's subscription. The normal world loads authentication data (such 
    as a username and password) into the cache and requests that the secure 
    world authenticate the user through a special instruction. This invokes the 
    monitor mode which context switches out the normal world virtual processor 
    and replaces it with the secure world virtual processor. The secure world 
    processor communicates with a remote server to authenticate the user.  
    Unless authentication has succeeded, any subsequent requests to play a 
    video will fail.
    % Adding an explanation of authentication seems to add complicated details 
    % like communication with a remote server, and it takes up a lot of writing 
    % space. Maybe we can skip this part and just cover the video playback part 
    % since this is only here as an example anyway.

    The video itself is sent to the device through an encrypted stream. The key 
    used for decryption is stored inside the secure world virtual processor .  
    To play the video, the user space application loads the encrypted data into 
    the cache, tagging it as normal world readable. It then issues a special 
    instruction to interact with the secure world which decrypts the stream, 
    which context switches to the secure world virtual processor as before. The 
    secure world virtual processor
    reads the encrypted data in the cache, decrypts it with a key that is only 
    readable by the secure world, tags it as readable by the normal world, and 
    invokes the monitor to return execution to the normal world. Note that the 
    data is not cleared from the TLB or cache during context switches.  The 
    normal world and secure world virtual processors can execute in separate 
    cores which communicate through the shared cache instead of context 
    switching, however, since they operate on the same data, it is generally 
    better if they share the same core allowing them to both access the data 
    quickly in the private cache. 

    This TrustZone inspired baseline protects the confidentiality of the secret 
    key and minimizes the trusted code base to a small software library.  
    However, it does not defend against timing channel attacks.
    For example, the adversary could measure the time spent in the secure world 
    while decrypting the video with a key. This depends on cache timing which 
    can be correlated with the key \cite{bernstein,others}.
    Since the adversary is capable of any software attack and 
    microarchitectural timing channels can be exploited in software, these 
    channels must be eliminated to meet all the security requirements of the 
    system.

    \subsection{Untrusted Driver}
    \subsubsection{Security Mechanisms}
    \subsection{Another Example}
    Is it desirable to have one that does not depend on TrustZone-like explicit 
    flow protection to show the generality of our proposed timing channel 
    protection?
    \subsubsection{Security Mechanisms}
