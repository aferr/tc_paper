\section{Timing Channels}
\label{sec:tc_sources}
The baseline architecture is vulnerable to microarchitectural timing channels 
caused by shared resources including the private and shared caches, the on chip 
network, the system bus, and the main memory. Furthermore, data-dependent 
variations in the timing parameters of microarchitectural components can cause 
timing channels even in the absence of sharing. In general, all 
microarchitectural timing channels may be classified as state based timing 
channels, resource contention based timing channels, or termination channels.  
We later present approaches to address timing channels of each of these kinds.

In a state based timing channel:
\begin{itemize}
    \item The time required to access a resource with state depends on the 
        contents of that state.
    \item An adversary can observe the time required to complete requests to 
        that resource made by one security domain (that it controls).
    \item Another security domain operating on secret data can modify this 
        state, and these modifications can possibly affect the request timings 
        observable by the adversary.
    \item These modifications can possibly depend on the secret.
\end{itemize}
When all of these conditions are met, the timings that the adversary can 
observe correlate with the secret, and sensitive information may be leaked.

There is a resource contention based timing channel whenever:
\begin{itemize}
    \item A resource can concurrently service a finite number of requests and 
        this limitation can affect the time required to service a request (e.g.  
        if a request can be delayed because the resource is servicing another 
        request).
    \item An adversary can observe the time required for requests to that 
        resource made by one security domain (that it controls).
    \item Another security domain that directly operates on a secret contends 
        for the same resource and this contention can affect the timings 
        observable by the adversary.
    \item Usage of this resource by the security domain operating on the secret 
        can possibly correlate with the secret.
\end{itemize}
Together, these conditions imply that the adversary can make requests to use a 
resource with a contention based timing channel and extract secrets from these 
timings.

If instead the adversary can directly observe the time required for the 
security domain operating on a secret to complete any action (e.g. run an 
entire program or complete a memory request), this is a termination channel.  
This differs from state based and resource contention based timing channels 
wherein an adversary can only measure the timings of a security domain that it 
controls, but not the security domain directly operating on a secret. The rest 
of this section classifies the timing channel vulnerabilities due to each 
microarchitectural component into this taxonomy, and provides elucidating 
examples of these classes of timing channels.

\subsection{Private Caches}
The baseline private caches are shared among security domains whenever a core 
context switches between them. Despite the lack of concurrent sharing, private 
caches cause information leakage between context switches and through variation 
in timing not due to sharing.

Private caches impose a state based timing channel even if each security domain 
has a totally disjoint address space (i.e. no security domain can read or write 
any memory address that another security domain can read or write). Requests to 
the memory hierarchy for addresses that are stored in the cache (cache hits) 
are returned faster than requests that are not stored in the cache (cache 
misses). So, the time required to access the cache depends on its state. An 
adversary controlling a security domain can use conventional time measurement 
libraries to record cache access timings and determine which requests are hits.
The adversary controlled security domain can be context switched out for one 
that will operate on some secret. This other domain can read new memory 
addresses into the cache which may evict some of the old entries that occupied 
the cache. The memory addresses used by this domain can depend on the actual 
data of the secret, for example, through a branch condition. (In the attack 
proposed by Bernstein \cite{bernstein} the addresses read by an AES algorithm 
depend on the secret key through sboxes). Therefore, this satisfies the 
definition of a state based timing channel.

The adversary can exploit this timing channel by loading an array from memory 
that occupies as many cache lines as possible. The adversary then waits until 
the virtual machine he or she controls is context switched out and replaced 
with the security domain that will operate on the secret. This security domain 
may evict some of the cache lines of the array. When the adversarial security 
domain context switches back, the adversary can learn which cache lines were 
evicted by making requests to read each element of the array and measuring the 
timing. It will take longer to read the elements which were evicted. Unless the 
cache is fully associative, the particular cache lines that were evicted will 
depend on the addresses operated on by the victim security domain. Even if the 
cache is fully associative, the adversary can use an array that completely 
fills the cache and learn the number of cache lines read by the adversary - a 
quantity that can also depend on a secret.

Additionally, private caches also cause termination channel vulnerabilities if 
the adversary can measure the duration of an event performed by a security 
domain that operates on some secret and includes one or more private cache
accesses. In the DRM video playback usage case, an example of such an event is 
a function call in the secure world that handles a request made by the normal 
world. The adversary can measure the time between making the request (invoking
the monitor to context switch the adversarial security domain out) and being 
context switched back in. The total time required to complete the function will 
depend on the cache hit ratio which depends on program control flow and 
therefore possibly the secret. This termination channel has the interesting 
property in that it requires no interference or resource sharing between the 
two security domains at all.
 
\subsection{TLBs and Branch Predictors}
As with private caches, TLBs are shared among security domains between context 
switches. The TLB effectively caches address translations, and since page table 
hits are faster than misses, it can be shown through similar reasoning as 
Section \ref{sec:priv_cache} that the TLB causes state based timing channels 
and termination channels. The branch predictor is also shared by domains 
between context switching. It stores branch prediction history in a branch 
prediction table, the contents of which are used to decide whether or not a 
branch should be taken. This prediction can positively or adversely affect 
execution time, and space in the branch prediction history table is finite, so 
evictions must be made. Again, similar reasoning can be applied to see that the 
branch predictor also causes state based and termination timing channels.

\subsection{Shared Caches}
Unlike the private caches, shared caches allow concurrently executing security 
domains to interfere with one another, although it induces similar state based 
and termination timing channels. As with private caches, if an operation 
performed on a secret by a victim security domain is  comprised with one or 
more shared cache accesses, the overall time to complete that action is 
possibly correlated with the secret. This termination channel is present even 
without any interference or resource sharing among security domains.
Also, one security domain can evict the cache lines of another security domain, 
however, in the shared cache this can happen while both are executing 
concurrently. This allows the attacker to have finer-grained control over when 
interference takes place, potentially allowing for faster exfiltration of 
secrets. However, since the shared cache is larger it has a higher access time, 
and since it is higher in the memory hierarchy the private cache reduces the 
chance of a shared cache access. Both of these factors decrease the 
exfiltration rate, so it is unclear if shared cache timing channels are more 
efficient than private cache timing channels.

\subsection{Main Memory}
The main memory is shared between concurrently executing security domains, and 
analogous to the timing disparity between cache hits and misses, page faults in 
main memory take substantially longer than accessing entries that are present 
in main memory. So the main memory has sources of timing channels that are 
similar to the shared cache. However, the memory controller has additional 
timing channels due to resource contention. Wang et. al. classify timing 
channel sources as queueing structure interference, scheduler arbitration 
interference, and DRAM Device interference. In this section these timing 
channel sources are summarized, and it is shown that each may also be thought
of as a resource contention based timing channel or a state based timing 
channel.

A memory controller queueing structure collects incoming requests for the DRAM 
and stores them in a queue. The state elements of the queue can accommodate 
only a finite number of requests. If the queue is completely filled, any 
incoming request must be stalled. Therefore, the time required to make a memory 
request depends on the state in the queueing structure. An adversary can 
measure the time required for its memory requests and learn if a victim 
security domain has completely occupied the queue or not (since the delay will 
be greater if the queue is full). This can indicate whether or not a secret 
dependent control flow segment led the victim program to a memory intensive 
region of of the program or not. These conditions imply that the finite queue 
space induces a state based timing channel.

Scheduler arbitration interference causes timing channels in a conventional 
memory controller whenever requests from two different security domains for 
different banks arrive at the queue at similar times. Depending on the specific 
scheduler policy, the one request will be favored causing the other request to 
be delayed. Often, this policy is designed to exploit row buffer locality. When 
a memory access takes place, the row being accessed is stored in a row buffer 
(sense amplifier). Accesses to rows that are already stored in the row buffer 
are faster than those which are not. This causes another state based timing 
channel.


Lastly, the queueing structure and scheduler arbitration both resolve 
contention for finite resources in the DRAM device (e.g., the command bus, data
bus, banks, and ranks).
For example, two requests to the same bank cannot be scheduled at the same 
time. If two security domains make a request for the same bank at the same 
time, one of them must be delayed.  When a victim security domain operating on 
a secret makes a memory request, the request will be mapped to a particular 
bank based on the address of the request. An adversary can employ a security 
domain he or she controls to simultaneously issue requests to the memory 
controller and measure the timing to determine if there is interference that 
might imply the victim is using a particular bank. This is a resource 
contention based timing channel, and similar arguments can be made to show that 
the other finite resources also cause resource contention based timing 
channels. 

The command bus and data bus timing channels are subtly different from the rank 
and bank timing channels. The particular rank and bank accessed by the victim 
security domain depend on the memory address, but the command and data bus are 
simply occupied by a request or not. These buses can still cause delays that 
imply the presence or absence of a victim request, and so these resources also 
cause timing variation which may depend on a secret.

\subsection{On Chip Network \& System Bus}
This section must still be completed, but it is likely that these timing 
channels can be viewed as resource contention based timing channels.
