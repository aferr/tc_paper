\section{Timing Channels}
\label{sec:tc_sources}
The baseline architecture is vulnerable to microarchitectural timing channels 
caused by shared resources including the private and shared caches, the on chip 
network, the system bus, and the main memory. Furthermore, data-dependent 
variations in the timing parameters of microarchitectural components can cause 
timing channels even in the absence of sharing. In general, all 
microarchitectural timing channels may be classified as state based timing 
channels, resource contention based timing channels, or termination channels.  
We later present approaches to address timing channels of each of these kinds.

In a state based timing channel:
\begin{itemize}
    \item The time required to access a resource with state depends on the 
        contents of that state. 
    \item An adversary can observe the time required to complete requests to 
        that resource made by one security domain (that it controls).
    \item Another security domain operating on secret data can modify this 
        state, and these modifications can possibly affect the request timings 
        observable by the adversary.
    \item These modifications can possibly depend on the secret.
\end{itemize}
When all of these conditions are met, the timings that the adversary can 
observe correlate with the secret, and sensitive information may be leaked.

There is a resource contention based timing channel whenever:
\begin{itemize}
    \item A resource can concurrently service a finite number of requests and 
        this limitation can affect the time required to service a request (e.g.  
        if a request can be delayed because the resource is servicing another 
        request).
    \item An adversary can observe the time required for requests to that 
        resource made by one security domain (that it controls).
    \item Another security domain that directly operates on a secret contends 
        for the same resource and this contention can affect the timings 
        observable by the adversary.
    \item Usage of this resource by the security domain operating on the secret 
        can possibly correlate with the secret.
\end{itemize}
Together, these conditions imply that the adversary can make requests to use a 
resource with a contention based timing channel and extract secrets from these 
timings.

If instead the adversary can directly observe the time required for the 
security domain operating on a secret to complete any action (e.g. run an 
entire program or complete a memory request), this is a termination channel.  
This differs from state based and resource contention based timing channels 
wherein an adversary can only measure the timings of a security domain that it 
controls, but not the security domain directly operating on a secret. The rest 
of this section classifies the timing channel vulnerabilities due to each 
microarchitectural component into this taxonomy, and provides elucidating 
examples of these classes of timing channels.

\subsection{Private Caches}
The baseline private caches are shared among security domains whenever a core 
context switches between them. Despite the lack of concurrent sharing, private 
caches cause information leakage between context switches and through variation 
in timing not due to sharing.

Private caches impose a state based timing channel even if each security domain 
has a totally disjoint address space (i.e. no security domain can read or write 
any memory address that another security domain can read or write). Requests to 
the memory hierarchy for addresses that are stored in the cache (cache hits) 
are returned faster than requests that are not stored in the cache (cache 
misses). So, the time required to access the cache depends on its state. An 
adversary controlling a security domain can use conventional time measurement 
libraries to record cache access timings and determine which requests are hits.
The adversary controlled security domain can be context switched out for one 
that will operate on some secret. This other domain can read new memory 
addresses into the cache which may evict some of the old entries that occupied 
the cache. The memory addresses used by this domain can depend on the actual 
data of the secret, for example, through a branch condition. (In the attack 
proposed by Bernstein \cite{bernstein} the addresses read by an AES algorithm 
depend on the secret key through sboxes). Therefore, this satisfies the 
definition of a state based timing channel.

The adversary can exploit this timing channel by loading an array from memory 
that occupies as many cache lines as possible. The adversary then waits until 
the virtual machine he or she controls is context switched out and replaced 
with the security domain that will operate on the secret. This security domain 
may evict some of the cache lines of the array. When the adversarial security 
domain context switches back, the adversary can learn which cache lines were 
evicted by making requests to read each element of the array and measuring the 
timing. It will take longer to read the elements which were evicted. Unless the 
cache is fully associative, the particular cache lines that were evicted will 
depend on the addresses operated on by the victim security domain. Even if the 
cache is fully associative, the adversary can use an array that completely 
fills the cache and learn the number of cache lines read by the adversary - a 
quantity that can also depend on a secret.

Additionally, private caches also cause termination channel vulnerabilities if 
the adversary can measure the duration of an event performed by a security 
domain that operates on some secret and includes one or more private cache
accesses. In the DRM video playback usage case, an example of such an event is 
a function call in the secure world that handles a request made by the normal 
world. The adversary can measure the time between making the request (invoking
the monitor to context switch the adversarial security domain out) and being 
context switched back in. The total time required to complete the function will 
depend on the cache hit ratio which depends on program control flow and 
therefore possibly the secret. This termination channel has the interesting 
property in that it requires no interference or resource sharing between the 
two security domains at all.
 
\subsection{TLBs and Branch Predictors}
As with private caches, TLBs and branch predictors are shared among security 
domains between context switches and have state that causes the total execution 
time of tasks to correlate with private data. As a result, similar approaches 
can be taken to prevent timing channels in all three of these per-core 
resources, however, different approaches may be desirable because each resource 
affects performance differently.

\subsection{Shared Caches}
Unlike the private caches, shared caches allow concurrently executing security 
domains to interfere with one another. However, the sources of timing channels 
are still similar to those in the private cache. As with private caches, it is 
possible for an adversary to exploit the ability of a higher level security 
domain to access entries owned by a lower level domain to determine which 
addresses are used. However the lower level domain can cause interference while 
the secure domain is executing, not just between context switches. This allows 
the attacker to have finer-grained control over when interference takes place, 
potentially allowing for faster exfiltration of secrets. Similarly, if a domain 
evicts cache entries owned by another concurrently executing domain with which 
the former domain shares the cache, the latter domain can observe this and 
potentially extract secret information. As with private caches, the timing of a 
single security domain depends on it's shared cache access pattern, and 
therefore, overall timing is correlated with data values even without 
interference.

\subsection{Main Memory}
The main memory is shared between concurrently executing security domains, and 
analogous to the timing disparity between cache hits and misses, page faults in 
main memory take substantially longer than accessing entries that are present 
in main memory. So the main memory has sources of timing channels that are 
similar to the shared cache. However, the memory controller has additional 
timing channels due to resource contention. Wang et. al. classify timing 
channel sources as queueing structure interference, scheduler arbitration 
interference, and DRAM Device interference. These timing channel sources are 
summarized here.

A typical memory controller queueing structure groups memory requests by bank 
and schedules them to achieve the best performance regardless of which security 
domain the requests came from. This queueing structure interference causes the 
time that requests from one domain are scheduled to depend on the presence of 
requests from another domain. Interference can be observed whenever a request 
from one domain is chosen over a request from another, or whenever one domain 
consumes the entire capacity of the queueing structure (thereby causing 
requests from other domains to stall).

Scheduler arbitration interference causes timing channels in a conventional 
memory controller whenever requests from two different security domains for 
different banks arrive at the queue at similar times. Depending on the specific 
scheduler policy, the one request will be favored causing the other request to 
be delayed.

Lastly, contention for finite resources in the DRAM device (e.g., the command 
bus, data bus, banks, and ranks) causes interference among security domains and 
timing channels. For example, two requests to the same bank cannot be scheduled 
at the same time. If two security domains make a request for the same bank at 
the same time, one of them must be delayed.

\subsection{On Chip Network \& System Bus}
