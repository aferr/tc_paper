\section{Related Work}

Previous studies have identified 
a number of microarchitectural timing channels in
caches~\cite{percival,bernstein,caseofaes,remoteaes,analyticalcache,collision,
deconstructing,cachegames}, branch predictors 
\cite{branchpred,predictingbranch}, processor
pipelines \cite{pipelines}, networks on chip~\cite{yaonocs,surfnoc}, and memory
controllers~\cite{ushpca14,fletcher-hpca14}. 
People have also proposed solutions for timing channels in
individual components such as caches~\cite{newcache,deconstructing}, memory
controllers~\cite{ushpca14,fletcher-hpca14}, and on-chip network
~\cite{yaonocs,surfnoc}.
% However, the previous work has
% so far focused on individual component. 
This work represents the first attempt
at designing a full microprocessor with complete inter-program timing channel protection.
Our integration efforts also exposed new sources of timing channels in module
interfaces such as MSHRs and cache/memory response ports.

%However, this paper presents the first microarchitecture to address all 
%internal microarchitectural timing channels. 

Ascend~\cite{ascend} proposes a
microarchitecture that aims to eliminate intra-program timing channels so that
even untrusted software can execute without leaking any confidential
data. This presents a powerful option if physical attacks need to be
considered. However, Ascend does not allow a processor to be shared by
multiple software components at the same time, and does not address 
any inter-program timing channels.
Execution leases~\cite{execution_leases} 
provide another intra-program timing channel solution at the hardware level by 
enforcing strict upper bounds on the execution times of program subsections. 

Timing channels are a form of information flow, and there is a large body
of work on information flow control. For example, language-level approaches
track information flow that is visible at the program level to either 
eliminate~\cite{quantleaks} or 
reduce~\cite{mitigation1,mitigation2,mitigation3} timing channels. 
However, language-level approaches cannot fully control microarchitecture-level
timing channels because traditional instruction set architecture hides
timing inside a processor.
At the 
systems level, information flow control has been used to control
explicit communication channels~\cite{flume-sosp07,histar-sosp06,laminar-pldi09}. 
These software approaches can control explicit information flows or intra-program
timing channels that the timing compartments do not handle.
The timing compartments complement these software approach by
controlling microarchitectural timing channels.

There have been recent efforts on verifying information flow properties
of hardware including certain timing channels. For example, GLIFT
\cite{glift-asplos09} dynamically tracks all information flows, including timing channels,
at the logic gate level. 
This idea has been extended to verifying
information flow properties using gate-level simulations
\cite{glift-dac10,glift-dac11,glift-isca11} and to a 
hardware description language
~\cite{caisson-plas10,caisson-pldi11,sapper-plas13}.
However, these approaches so far have only been applied to simple
processors and a very strict isolation mechanism. 
This paper studies timing channel protection on complex multi-core processors.

