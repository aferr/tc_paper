\section{Related Work}

Previous studies identified 
a number of microarchitectural timing channels 
caches~\cite{percival,bernstein,caseofaes,remoteaes,analyticalcache,collision,
deconstructing,cachegames}, branch predictors 
\cite{branchpred,predictingbranch}, processor
pipelines \cite{pipelines}, networks on chip~\cite{yaonocs,surfnoc}, and memory
controllers~\cite{ushpca14,fletcher-hpca14}. 
Also, people have proposed solutions for timing channels in
individual components such as caches~\cite{newcache,deconstructing}, memory
controllers~\cite{ushpca14,fletcher-hpca14}, and on-chip network
~\cite{yaonocs,surfnoc}.
However, the previous work has
so far focused on individual component. This work represents the first attempt
at designing a full microprocessor with complete internal timing channel protection.
Our integration efforts also exposed new sources of timing channels in module
interfaces such as MSHRs and cache/memory response ports.

%However, this paper presents the first microarchitecture to address all 
%internal microarchitectural timing channels. 

Ascend~\cite{ascend} proposes a
microarchitecture that aims to eliminate external timing channels so that
even untrusted software can execute without leaking any confidential
data. This presents a powerful option if physical attacks need to be
considered. However, Ascend does not allow a processor to be shared by
multiple software components at the same time, and does not address 
any internal timing channels.
Execution leases~\cite{execution_leases} 
provide another external timing channel solution at the hardware level by 
enforcing strict upper bounds on the execution times of program subsections. 

Timing channels are a form of information flow, and many approaches to 
controlling timing channels are based in information flow theory. Language 
level approaches track information flow and to either 
eliminate~\cite{quantleaks} or 
reduce~\cite{mitigation1,mitigation2,mitigation3} timing channels. At the 
systems level, information flow has been used to provide security 
through explicit channels ~\cite{flume-sosp07,histar-sosp06,laminar-pldi09}. 
These can be combined with timing compartments to provide total software 
isolation.

Work has also been done to verify hardware timing channel protection. GLIFT 
\cite{glift-asplos09} tracks all information flows, (including timing channels) 
in hardware at the gate level, though it does so at a high cost. GLIFT has 
later been used to develop information flow property checkers in gate level 
simulators ~\cite{glift-dac10,glift-dac11,glift-isca11}, and more recently 
hardware description languages that verify timing channel securtity 
~\cite{caisson-plas10,caisson-pldi11,sapper-plas13}.
