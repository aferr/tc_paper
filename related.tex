\section{Related Work}

Previous studies identified 
a number of microarchitectural timing channels 
caches~\cite{percival,bernstein,caseofaes,remoteaes,analyticalcache,collision,
deconstructing,cachegames}, branch predictors 
\cite{branchpred,predictingbranch}, processor
pipelines \cite{pipelines}, networks on chip~\cite{yaonocs,surfnoc}, and memory
controllers~\cite{ushpca14,fletcher-hpca14}. 
Also, people have proposed solutions for timing channels in
individual components such as caches~\cite{newcache,deconstructing}, memory
controllers~\cite{ushpca14,fletcher-hpca14}, and on-chip network
~\cite{yaonocs,surfnoc}.
However, the previous work has
so far focused on individual component. This work represents the first attempt
at designing a full microprocessor with complete internal timing channel protection.
Our integration efforts also exposed new sources of timing channels in module
interfaces such as MSHRs and cache/memory response ports.

%However, this paper presents the first microarchitecture to address all 
%internal microarchitectural timing channels. 

Ascend~\cite{ascend} proposes a
microarchitecture that aims to eliminate external timing channels so that
even untrusted software can execute without leaking any confidential
data. This presents a powerful option if physical attacks need to be
considered. However, Ascend does not allow a processor to be shared by
multiple software components at the same time, and does not address 
any internal timing channels.
Execution leases~\cite{execution_leases} 
provide another external timing channel solution at the hardware level by 
enforcing strict upper bounds on the execution times of program subsections. 

Timing channels are a form of information flow, and there is a large body
of work on information flow control. For example, language-level approaches
track information flow that is visible at the program level to either 
eliminate~\cite{quantleaks} or 
reduce~\cite{mitigation1,mitigation2,mitigation3} timing channels. 
However, language-level approaches cannot fully control microarchitecture-level
timing channels because traditional instruction set architecture hides
timing inside a processor.
At the 
systems level, information flow control has been used to control
explicit communication channels~\cite{flume-sosp07,histar-sosp06,laminar-pldi09}. 
These software approaches can control explicit information flows or external
timing channels that the timing compartments do not handle.
The timing compartments complement these software approach by
controlling microarchitectural timing channels.

There have been recent efforts on verifying information flow properties
of hardware including certain timing channels. For example, GLIFT
\cite{glift-asplos09} dynamically tracks all information flows, including timing channels,
at the logic gate level. 
The idea in GLIFT has been extended to develop verifying
information flow properties using gate-level simulations
\cite{glift-dac10,glift-dac11,glift-isca11} and a 
hardware description language
~\cite{caisson-plas10,caisson-pldi11,sapper-plas13}.
However, these approaches so far have only been applied to simple
processors and a very strict isolation mechanism. 
This paper studies timing channel protection on complex multi-core processors.

